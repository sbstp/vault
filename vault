#!/usr/bin/env python3

import json
import os
import sys
import tarfile
from collections import OrderedDict
from os import path


def printf(fmt, *args, **kwargs):
    print(fmt.format(*args, **kwargs), end='')


def first_existing_parent(file):
    cur_path = path.dirname(file)
    while not path.exists(cur_path):
        cur_path = path.dirname(cur_path)
    return cur_path


def makedirs(fullpath, uid, gid):
    if not path.exists(fullpath):
        parent, _ = path.split(fullpath)
        makedirs(parent, uid, gid)
        os.mkdir(fullpath)
        os.chown(fullpath, uid, gid)


def can_read(file):
    return os.access(file, os.R_OK)


def can_write(file):
    if not path.exists(file):
        parent = first_existing_parent(file)
        return os.access(parent, os.W_OK)
    return os.access(file, os.W_OK)


class Registry:

    def __init__(self):
        self._vault_path = path.join(path.expanduser("~"), ".vault")
        if path.exists(self._vault_path):
            with open(self._vault_path) as f:
                self.paths = json.load(f)
        else:
            self.paths = []

    def add_path(self, new_path):
        idx = 0
        while idx < len(self.paths):
            if new_path == self.paths[idx]:
                return
            if new_path < self.paths[idx]:
                self.paths.insert(idx, new_path)
                return
            idx += 1
        self.paths.append(new_path)

    def rm_path(self, rm_path):
        try:
            self.paths.remove(rm_path)
        except ValueError:
            pass

    def save(self):
        with open(self._vault_path, 'w') as f:
            json.dump(self.paths, f)

    def backup_to(self, backup_path):
        for item in self.paths:
            if not can_read(item):
                raise PermissionError(item)

        with tarfile.open(backup_path, "w:gz") as tar:
            for item in self.paths:
                printf("Backed up {}\n", item)
                tar.add(item)

    def restore_from(self, backup_path):
        with tarfile.open(backup_path, "r:*") as tar:
            for mem in tar.getmembers():
                file = path.join("/", mem.name)
                if not can_write(file):
                    raise PermissionError(file)

            for mem in tar.getmembers():
                file = path.join("/", mem.name)
                # create any missing directory with the file's owner and group
                makedirs(path.dirname(file), mem.uid, mem.gid)
                tar.extract(mem, "/")
                self.add_path(file)
                printf("Restored {}\n", file)


class Command:

    def __init__(self, name, func, args_help="", help=""):
        self.name = name
        self.func = func
        self.args_help = args_help
        self.help = help


class Commands:

    def __init__(self):
        self._commands = OrderedDict()

    def add_command(self, name, func, args_help="", help=""):
        self._commands[name] = Command(name, func, args_help, help)

    def print_help(self, unknown=None):
        if unknown is not None:
            printf("Unknown command '{}'\n\n", unknown)
        printf("Usage: vault <command>\n\n")
        printf("Commands:\n")

        max_cmd_len = max(len(cmd.name) for cmd in self._commands.values()) + 2
        max_args_help_len = max(len(cmd.args_help) for cmd in self._commands.values()) + 2
        for cmd in self._commands.values():
            printf("  {}{}{}\n", cmd.name.ljust(max_cmd_len), cmd.args_help.ljust(max_args_help_len), cmd.help)

    def dispatch(self, args):
        if len(args) == 0:
            self.print_help()
            return
        cmd_name = args[0]
        rest = args[1:]

        if cmd_name in ('-h', '--help', 'help'):
            self.print_help()
            return

        cmd = self._commands.get(cmd_name, None)
        if cmd is None:
            self.print_help(unknown=cmd_name)
        else:
            try:
                cmd.func(*rest)
            except TypeError as err:
                printf("Invalid argument for command '{}'\n", cmd_name)


if __name__ == '__main__':
    reg = Registry()
    commands = Commands()

    def cmd_add(*paths):
        for new_path in paths:
            new_path = path.abspath(new_path)
            reg.add_path(new_path)

    def cmd_rm(*paths):
        for rm_path in paths:
            rm_path = path.abspath(rm_path)
            reg.rm_path(rm_path)

    def cmd_ls():
        for item in reg.paths:
            printf("{}\n", item)

    def cmd_backup(backup_path):
        backup_path = path.abspath(backup_path)
        try:
            reg.backup_to(backup_path)
        except PermissionError as err:
            printf("Cannot read from {}, backup aborting.\n", err.args[0])

    def cmd_restore(backup_path):
        backup_path = path.abspath(backup_path)
        try:
            reg.restore_from(backup_path)
        except PermissionError as err:
            printf("Cannot write to {}, restore aborting.\n", err.args[0])

    commands.add_command("add", cmd_add, "<path> [<path>...]", "Add files to the index")
    commands.add_command("rm", cmd_rm, "<path> [<path>...]", "Remove files from the index")
    commands.add_command("ls", cmd_ls, "", "List files in the index")
    commands.add_command("backup", cmd_backup, "<backup_path>", "Backup files in the index")
    commands.add_command("restore", cmd_restore, "<backup_path>", "Restore files from the index")
    commands.dispatch(sys.argv[1:])

    reg.save()
